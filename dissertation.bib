@article{typesystem,
    author    = "Hui Jiang and Dong Lin and Xingyuan Zhang and Xiren Xie",
    year =  2001,
    pages = "286-292",
    title     = "Type system in programming languages",
    journal = "Journal of Computer Science and Technology"
}

@article{staticTyping,
    author = {Bruce, Kim},
    year = {2002},
    month = {01},
    pages = {},
    title = {Foundations of Object-Oriented Programming Languages: Types and Semantics}
}

@inproceedings{dynamicTyping,
    author = {Pil, Marco},
    title = {Dynamic Types and Type Dependent Functions},
    year = {1998},
    isbn = {3540662294},
    publisher = {Springer-Verlag},
    address = {Berlin, Heidelberg},
    booktitle = {Selected Papers from the 10th International Workshop on 10th International Workshop},
    pages = {169–185},
    numpages = {17},
    series = {IFL '98}
}

@online{java,
    author    = "Oracle",
    title     = "Java™ Programming Language",
    url       = "https://docs.oracle.com/javase/7/docs/technotes/guides/language/",
    urldate   = "2020-11-06"
}

@online{cpp,
    author    = "cplusplus.com",
    title     = "Information on the C++ language",
    url       = "https://www.cplusplus.com/info/",
    urldate   = "2020-11-06"
}

@online{c,
    author    = "cppreference.com",
    title     = "C language",
    url       = "https://en.cppreference.com/w/c/language",
    urldate   = "2020-12-16"
}

@online{python,
    author    = "Python Software Foundation",
    title     = "Python",
    url       = "https://www.python.org/",
    urldate   = "2020-12-16"
}

@online{js,
    author    = "JavaScript.com",
    title     = "JavaScript",
    url       = "https://www.javascript.com/",
    urldate   = "2020-12-16"
}

@article{inferenceType,
    author = {Pierce, Benjamin C. and Turner, David N.},
    title = {Local Type Inference},
    year = {2000},
    issue_date = {Jan. 2000},
    publisher = {Association for Computing Machinery},
    address = {New York, NY, USA},
    volume = {22},
    number = {1},
    issn = {0164-0925},
    url = {https://doi.org/10.1145/345099.345100},
    doi = {10.1145/345099.345100},
    journal = {ACM Trans. Program. Lang. Syst.},
    month = jan,
    pages = {1–44},
    numpages = {44},
    keywords = {subtyping, type inference, polymorphism}
}

@online{javaDuckType,
    author    = "Beyond Java",
    title     = "A Java Approach to Duck Typing Makes Reflection Easy",
    url       = "https://www.beyondjava.net/duck-typing-in-java",
    urldate   = "2020-12-16"
}

@online{cSharp,
    author    = "Microsoft",
    title     = "C# documentation",
    url       = "https://docs.microsoft.com/en-us/dotnet/csharp/",
    urldate   = "2020-12-16"
}

@online{goInferenceType,
    author    = "Golang",
    title     = "A Tour of Go: Type inference",
    url       = "https://tour.golang.org/basics/14",
    urldate   = "2020-12-16"
}

@Inbook{depenTypeAtWork,
    author="Bove, Ana and Dybjer, Peter",
    editor="Bove, Ana
    and Barbosa, Lu{\'i}s Soares
    and Pardo, Alberto
    and Pinto, Jorge Sousa",
    title="Dependent Types at Work",
    bookTitle="Language Engineering and Rigorous Software Development: International LerNet ALFA Summer School 2008, Piriapolis, Uruguay, February 24 - March 1, 2008, Revised Tutorial Lectures",
    year="2009",
    publisher="Springer Berlin Heidelberg",
    address="Berlin, Heidelberg",
    pages="57--99",
    isbn="978-3-642-03153-3",
    doi="10.1007/978-3-642-03153-3_2"
}

@misc{refinementTypes,
      title={Refinement Types: A Tutorial}, 
      author={Ranjit Jhala and Niki Vazou},
      year={2020},
      eprint={2010.07763},
      archivePrefix={arXiv},
      primaryClass={cs.PL}
}

@article{liquidTypes,
    author = {Rondon, Patrick M. and Kawaguci, Ming and Jhala, Ranjit},
    title = {Liquid Types},
    year = {2008},
    issue_date = {June 2008},
    publisher = {Association for Computing Machinery},
    address = {New York, NY, USA},
    volume = {43},
    number = {6},
    issn = {0362-1340},
    url = {https://doi.org/10.1145/1379022.1375602},
    doi = {10.1145/1379022.1375602},
    abstract = {We present Logically Qualified Data Types, abbreviated to Liquid Types, a system that combines Hindley-Milner type inference with Predicate Abstraction to automatically infer dependent types precise enough to prove a variety of safety properties. Liquid types allow programmers to reap many of the benefits of dependent types, namely static verification of critical properties and the elimination of expensive run-time checks, without the heavy price of manual annotation. We have implemented liquid type inference in DSOLVE, which takes as input an OCAML program and a set of logical qualifiers and infers dependent types for the expressions in the OCAML program. To demonstrate the utility of our approach, we describe experiments using DSOLVE to statically verify the safety of array accesses on a set of OCAML benchmarks that were previously annotated with dependent types as part of the DML project. We show that when used in conjunction with a fixed set of array bounds checking qualifiers, DSOLVE reduces the amount of manual annotation required for proving safety from 31% of program text to under 1%.},
    journal = {SIGPLAN Not.},
    month = jun,
    pages = {159–169},
    numpages = {11},
    keywords = {dependent types, hindley-milner, predicate abstraction, type inference}
}

@inproceedings{cHoward,
  title={The formulae-as-types notion of construction},
  author={W. A. Howard},
  year={1969}
}

@book{subsetTypes,
  title={Types and specifications},
  author={Nordstr{\"o}m, Bengt and Petersson, Kent},
  year={1983},
  publisher={Chalmers Tekniska H{\"o}gskola/G{\"o}teborgs Universitet. Programming Methodology Group}
}

@online{epigram,
    author    = {{e-pig.org}},
    title     = "Epigram: Making Dependent Type Matters",
    url       = "http://www.e-pig.org/",
    urldate   = "2020-11-02"
}

@online{agda,
    author    = "Ulf Norell and Andreas Abel and Nils A. Danielsson and M. Takeyama, Catarina Coquand",
    title     = "Agda",
    url       = "https://agda.readthedocs.io/",
    urldate   = "2020-11-02"
}

@online{coq,
    author    = "The Coq development team",
    title     = "The Coq Proof Assistant",
    url       = "https://coq.inria.fr/",
    urldate   = "2020-11-02"
}

@online{idris,
    author    = "Edwin Brady",
    title     = "Idris: A Language for Type-Driven Development",
    url       = "https://www.idris-lang.org/",
    urldate   = "2020-11-11"
}

@online{scala,
    author    = "École Polytechnique Fédérale Lausanne",
    title     = "The Scala Programming Language",
    url       = "https://www.scala-lang.org/",
    urldate   = "2021-03-24"
}

@online{refinedScala,
    author    = "fthomas",
    title     = "refined: simple refinement types for Scala",
    url       = "https://github.com/fthomas/refined",
    urldate   = "2021-03-24"
}

@inproceedings{xanadu,
    author    = {Hongwei Xi},
    title     = {Imperative Programming with Dependent Types},
    booktitle = {15th Annual {IEEE} Symposium on Logic in Computer Science, Santa Barbara,
    California, USA, June 26-29, 2000},
    pages     = {375--387},
    publisher = {{IEEE} Computer Society},
    year      = {2000},
    url       = {https://doi.org/10.1109/LICS.2000.855785},
    doi       = {10.1109/LICS.2000.855785},
    timestamp = {Wed, 16 Oct 2019 14:14:54 +0200},
    biburl    = {https://dblp.org/rec/conf/lics/Xi00.bib},
    bibsource = {dblp computer science bibliography, https://dblp.org}
}

@article{objOritentedDependentType,
    author    = {Joana Campos and Vasco T. Vasconcelos},
    title     = {Dependent Types for Class-based Mutable Objects (Artifact)},
    journal   = {Dagstuhl Artifacts Ser.},
    volume    = {4},
    number    = {3},
    pages     = {01:1--01:2},
    year      = {2018},
    url       = {https://doi.org/10.4230/DARTS.4.3.1},
    doi       = {10.4230/DARTS.4.3.1},
    timestamp = {Tue, 01 Sep 2020 14:09:22 +0200},
    biburl    = {https://dblp.org/rec/journals/darts/CamposV18.bib},
    bibsource = {dblp computer science bibliography, https://dblp.org}
}

@inproceedings{ynot,
    title={Ynot: dependent types for imperative programs},
    author={Aleksandar Nanevski and Greg Morrisett and Avraham Shinnar and Paul Govereau and L. Birkedal},
    booktitle={ICFP 2008},
    year={2008}
}

@inproceedings{htt,
    author    = {Aleksandar Nanevski and
    Greg Morrisett and
    Lars Birkedal},
    editor    = {John H. Reppy and
    Julia L. Lawall},
    title     = {Polymorphism and separation in Hoare type theory},
    booktitle = {Proceedings of the 11th {ACM} {SIGPLAN} International Conference on
    Functional Programming, {ICFP} 2006, Portland, Oregon, USA, September
    16-21, 2006},
    pages     = {62--73},
    publisher = {{ACM}},
    year      = {2006},
    url       = {https://doi.org/10.1145/1159803.1159812},
    doi       = {10.1145/1159803.1159812},
    timestamp = {Tue, 06 Nov 2018 16:59:24 +0100},
    biburl    = {https://dblp.org/rec/conf/icfp/NanevskiMB06.bib},
    bibsource = {dblp computer science bibliography, https://dblp.org}
}

@article{errorHandlingCode,
    author = {Cabral, Bruno and Sacramento, Paulo and Marques, Paulo},
    year = {2008},
    month = {01},
    pages = {233 - 250},
    title = {Hidden truth behind .NET's exception handling today},
    volume = {1},
    journal = {Software, IET},
    doi = {10.1049/iet-sen:20070017}
}

@article{lambdaCalculus,
    author    = {Ra{\'{u}}l Rojas},
    title     = {A Tutorial Introduction to the Lambda Calculus},
    journal   = {CoRR},
    volume    = {abs/1503.09060},
    year      = {2015},
    url       = {http://arxiv.org/abs/1503.09060},
    archivePrefix = {arXiv},
    eprint    = {1503.09060},
    timestamp = {Mon, 23 Nov 2020 14:35:57 +0100},
    biburl    = {https://dblp.org/rec/journals/corr/Rojas15.bib},
    bibsource = {dblp computer science bibliography, https://dblp.org}
}

@inproceedings{monads,
    author = {Wadler, Philip},
    title = {Monads for Functional Programming},
    year = {1995},
    isbn = {3540594515},
    publisher = {Springer-Verlag},
    address = {Berlin, Heidelberg},
    booktitle = {Advanced Functional Programming, First International Spring School on Advanced Functional Programming Techniques-Tutorial Text},
    pages = {24–52},
    numpages = {29}
}

@article{overviewFP,
    author = {Kunasaikaran, Jagatheesan and Iqbal, Azlan},
    year = {2016},
    month = {12},
    pages = {32},
    title = {A Brief Overview of Functional Programming Languages},
    volume = {6},
    journal = {electronic Journal of Computer Science and Information Technology}
}


@article{purelyFP,
    title={What is a Purely Functional Language?},
    author={A. Sabry},
    journal={J. Funct. Program.},
    year={1998},
    volume={8},
    pages={1-22}
}

@inproceedings{fpHarder,
    author = {Khanfor, Abdullah and Yang, Ye},
    year = {2017},
    month = {12},
    pages = {50-54},
    title = {An Overview of Practical Impacts of Functional Programming},
    doi = {10.1109/APSECW.2017.27}
}

@online{haskell,
    author    = "haskell.org",
    title     = "Haskell: An advanced, purely functional programming language",
    url       = "https://www.haskell.org/",
    urldate   = "2020-12-18"
}

@online{pypl,
    author    = "Pierre Carbonnelle",
    title     = "PYPL PopularitY of Programming Language",
    url       = "https://pypl.github.io/",
    urldate   = "2020-12-18"
}

@online{haskellFB,
    author    = "Facebook Engineering",
    title     = "Fighting spam with Haskell",
    url       = "https://engineering.fb.com/2015/06/26/security/fighting-spam-with-haskell/",
    urldate   = "2020-12-18"
}

@article{rts,
  author    = {Panagiotis Vekris and
               Benjamin Cosman and
               Ranjit Jhala},
  title     = {Refinement Types for TypeScript},
  journal   = {CoRR},
  volume    = {abs/1604.02480},
  year      = {2016},
  url       = {http://arxiv.org/abs/1604.02480},
  archivePrefix = {arXiv},
  eprint    = {1604.02480},
  timestamp = {Mon, 13 Aug 2018 16:46:27 +0200},
  biburl    = {https://dblp.org/rec/journals/corr/VekrisCJ16.bib},
  bibsource = {dblp computer science bibliography, https://dblp.org}
}

@article{haskellGADT,
    author = {Pottier, Fran\c{c}ois and R\'{e}gis-Gianas, Yann},
    title = {Stratified Type Inference for Generalized Algebraic Data Types},
    year = {2006},
    issue_date = {January 2006},
    publisher = {Association for Computing Machinery},
    address = {New York, NY, USA},
    volume = {41},
    number = {1},
    issn = {0362-1340},
    url = {https://doi.org/10.1145/1111320.1111058},
    doi = {10.1145/1111320.1111058},
    abstract = {Stratified type inference for generalized algebraic data types.},
    journal = {SIGPLAN Not.},
    month = jan,
    pages = {232–244},
    numpages = {13}
}

@online{dependentHaskell,
    author    = "ghc-proposals",
    title     = "GitHub: ghc-proposals",
    url       = "https://github.com/ghc-proposals/ghc-proposals",
    urldate   = "2020-12-18"
}

@misc{aRoleForDependentHaskell,
    title={A Role for Dependent Types in Haskell (Extended version)}, 
    author={Stephanie Weirich and Pritam Choudhury and Antoine Voizard and Richard A. Eisenberg},
    year={2019},
    eprint={1905.13706},
    archivePrefix={arXiv},
    primaryClass={cs.PL}
}

@inproceedings{liquidHaskell,
  author    = {Ricardo Pe{\~{n}}a},
  editor    = {Alicia Villanueva},
  title     = {An Introduction to Liquid Haskell},
  booktitle = {Proceedings {XVI} Jornadas sobre Programaci{\'{o}}n y Lenguajes,
               {PROLE} 2016, Salamanca, Spain, 14-16th September 2016},
  series    = {{EPTCS}},
  volume    = {237},
  pages     = {68--80},
  year      = {2016},
  url       = {https://doi.org/10.4204/EPTCS.237.5},
  doi       = {10.4204/EPTCS.237.5},
  timestamp = {Wed, 12 Sep 2018 01:05:15 +0200},
  biburl    = {https://dblp.org/rec/journals/corr/Pena17.bib},
  bibsource = {dblp computer science bibliography, https://dblp.org}
}

@online{gpIdris,
    author    = "The Idris Community",
    title     = "Idris: Frequently Asked Questions",
    url       = "http://docs.idris-lang.org/en/latest/faq/faq.html",
    urldate   = "2021-01-04"
}

@Inbook{imperativeOverview,
    author="Syme, Don
    and Granicz, Adam
    and Cisternino, Antonio",
    editor="Andres, Clay
    and Anglin, Steve
    and Beckner, Mark
    and Buckingham, Ewan
    and Cornell, Gary
    and Gennick, Jonathan
    and Hassell, Jonathan
    and Lowman, Michelle
    and Moodie, Matthew
    and Parkes, Duncan
    and Pepper, Jeffrey
    and Pohlmann, Frank
    and Pundick, Douglas
    and Renow-Clarke, Ben
    and Shakeshaft, Dominic
    and Wade, Matt
    and Welsh, Tom
    and Castro, Anita
    and Taylor, Tiffany",
    title="Introducing Imperative Programming",
    bookTitle="Expert F{\#} 2.0",
    year="2009",
    publisher="Apress",
    address="Berkeley, CA",
    pages="67--96",
    abstract="In Chapter 3, you saw some of the simple but powerful data types and language constructs that make up F{\#} functional programming. The functional programming paradigm is strongly associated with ``programming without side effects,'' called pure functional programming. In this paradigm, programs compute the result of a mathematical expression and don't cause any side effects, except perhaps reporting the result of the computation. The formulas used in spreadsheets are often pure, as is the core of functional programming languages such as Haskell. F{\#} isn't, however, a pure functional language. For example, you can write programs that mutate data, perform I/O communications, start threads, and raise exceptions. Furthermore, the F{\#} type system doesn't enforce a strict distinction between expressions that perform these actions and expressions that don't.",
    isbn="978-1-4302-2432-7",
    doi="10.1007/978-1-4302-2432-7_4",
url="https://doi.org/10.1007/978-1-4302-2432-7_4"
}

@online{cppTemplate,
    author    = "cplusplus.com",
    title     = "C++: Templates",
    url       = "https://www.cplusplus.com/doc/oldtutorial/templates/",
    urldate   = "2021-01-04"
}

@online{javaGenerics,
    author    = "Oracle Corporation",
    title     = "The Java Tutorials: Why use Generics",
    url       = "https://docs.oracle.com/javase/tutorial/java/generics/why.html",
    urldate   = "2021-01-04"
}

@online{cppConstExpr,
    author    = "cppreference.com",
    title     = "C++: constexpr specifier",
    url       = "https://en.cppreference.com/w/cpp/language/constexpr",
    urldate   = "2021-01-04"
}

@article{ATS,
  author    = {Hongwei Xi},
  title     = {Applied Type System: An Approach to Practical Programming with Theorem-Proving},
  journal   = {CoRR},
  volume    = {abs/1703.08683},
  year      = {2017},
  url       = {http://arxiv.org/abs/1703.08683},
  archivePrefix = {arXiv},
  eprint    = {1703.08683},
  timestamp = {Mon, 13 Aug 2018 16:47:04 +0200},
  biburl    = {https://dblp.org/rec/journals/corr/Xi17.bib},
  bibsource = {dblp computer science bibliography, https://dblp.org}
}

@online{FStar,
    author    = " Microsoft Research and Inria,",
    title     = "C++: constexpr specifier",
    url       = "http://fstar-lang.org/",
    urldate   = "2021-01-20"
}

@article{whileLanguage,
  author    = {Cl{\'{a}}udio Vasconcelos and
               Ant{\'{o}}nio Ravara},
  title     = {The While language},
  journal   = {CoRR},
  volume    = {abs/1603.08949},
  year      = {2016},
  url       = {http://arxiv.org/abs/1603.08949},
  archivePrefix = {arXiv},
  eprint    = {1603.08949},
  timestamp = {Mon, 13 Aug 2018 16:47:54 +0200},
  biburl    = {https://dblp.org/rec/journals/corr/VasconcelosR16.bib},
  bibsource = {dblp computer science bibliography, https://dblp.org}
}

@inproceedings{FOL,
    author = {Cartwright, Robert and McCarthy, John},
    title = {First Order Programming Logic},
    year = {1979},
    isbn = {9781450373579},
    publisher = {Association for Computing Machinery},
    address = {New York, NY, USA},
    url = {https://doi.org/10.1145/567752.567759},
    doi = {10.1145/567752.567759},
    abstract = {First Order Programming Logic is a simple, yet powerful formal system for reasoning about recursive programs. In its simplest form, it has one major limitation: it cannot establish any property of the least fixed point of a recursive program which is false for some other fixed point. To rectify this weakness, we present two intuitively distinct approaches to strengthening First Order Programming Logic and prove that either extension makes the logic relatively complete. In the process, we prove that the two approaches are formally equivalent. The relative completeness of the extended logic is significant because it suggests it can establish all "ordinary" properties (obviously we cannot escape the Godelian incompleteness inherent in any programming logic) of recursive programs including those which compute partial functions.The second contribution of this paper is to establish that First Order Programming Logic is applicable to iterative programs as well. In particular, we show that the intermittent assertions method--an informal proof method for iterative programs which has not been formalized--is conveniently formalized simply as sugared First Order Programming Logic applied to the recursive translations of iterative programs.},
    booktitle = {Proceedings of the 6th ACM SIGACT-SIGPLAN Symposium on Principles of Programming Languages},
    pages = {68–80},
    numpages = {13},
    location = {San Antonio, Texas},
    series = {POPL '79}
}

@article{operationalSemantics,
    author = {Prasad, Sanjiva and Arun-Kumar, S.},
    year = {2002},
    month = {09},
    pages = {},
    title = {Introduction to Operational Semantics},
    journal = {The Compiler Design Handbook: Optimizations and Machine Code Generation},
    doi = {10.1201/9781420040579.ch22}
}

@article{plotkinSOS,
    title = "The origins of structural operational semantics",
    journal = "The Journal of Logic and Algebraic Programming",
    volume = "60-61",
    pages = "3 - 15",
    year = "2004",
    note = "Structural Operational Semantics",
    issn = "1567-8326",
    doi = "https://doi.org/10.1016/j.jlap.2004.03.009",
    url = "http://www.sciencedirect.com/science/article/pii/S1567832604000268",
    author = "Gordon D Plotkin",
    keywords = "Semantics of programming languages, (Structural) operational semantics, Structural induction, (Labelled) transition systems, -calculus, Concurrency, Big step semantics, Small-step semantics, Abstract machines, Static semantics",
}

@online{effectFinal,
    author    = "Oracle Inc",
    title     = "The Java™ Tutorials: Anonymous Classes",
    url       = "https://docs.oracle.com/javase/tutorial/java/javaOO/anonymousclasses.html",
    urldate   = "2020-02-13"
}

@online{pbv,
    author    = "Edpresso Team",
    title     = "Pass by value vs. pass by reference",
    url       = "https://www.educative.io/edpresso/pass-by-value-vs-pass-by-reference",
    urldate   = "2021-01-11"
}

@online{cpplrvalues,
    author    = "cppreference.com",
    title     = "C++: Value categories",
    url       = "https://en.cppreference.com/w/cpp/language/value_category",
    urldate   = "2021-02-02"
}

@Inbook{hoare,
    author="Bloom, Stephen L.  and {\'E}sik, Zolt{\'a}n",
    title="Floyd-Hoare Logic",
    bookTitle="Iteration Theories: The Equational Logic of Iterative Processes",
    year="1993",
    publisher="Springer Berlin Heidelberg",
    address="Berlin, Heidelberg",
    pages="551--611",
    doi="10.1007/978-3-642-78034-9_15",
    url="https://doi.org/10.1007/978-3-642-78034-9_15"
}

@article{featInteract,
    author = {Calder, Muffy and Kolberg, Mario and Magill, Evan H. and Reiff-Marganiec, Stephan},
    title = {Feature Interaction: A Critical Review and Considered Forecast},
    year = {2003},
    issue_date = {15 January 2003},
    publisher = {Elsevier North-Holland, Inc.},
    address = {USA},
    volume = {41},
    number = {1},
    issn = {1389-1286},
    url = {https://doi.org/10.1016/S1389-1286(02)00352-3},
    doi = {10.1016/S1389-1286(02)00352-3},
    abstract = {The state of the art of the field of feature interactions in telecommunications services is reviewed, concentrating on three major research trends: software engineering approaches, formal methods, and on line techniques. Then, the impact of the new, emerging architectures on the feature interaction problem is considered. A forecast is made about how research in feature interactions needs to readjust to address the new challenges posed by the emerging architectures.},
    journal = {Comput. Netw.},
    month = jan,
    pages = {115–141},
    numpages = {27},
    keywords = {telecommunications services, incompatibility, feature interaction}
}

@article{heapVsStack,
    author = {S.Poornima, and Rao, Chakunta and Thabassum, Nazia and Anandaraj, Dr.S.P.},
    year = {2014},
    month = {12},
    pages = {1977- 1982},
    title = {Memory Management by Using the Heap and the Stack in Java},
    volume = {4},
    journal = {International Journal of Research In Computer Science & Engineering (IJRCSE)}
}

@article{RussellMathematicalLA,
  title={Mathematical Logic as Based on the Theory of Types},
  author={B. Russell},
  journal={American Journal of Mathematics},
  volume={30},
  pages={222}
}

@book{martinLof,
  author    = {Per Martin{-}L{\"{o}}f},
  title     = {Intuitionistic type theory},
  series    = {Studies in proof theory},
  volume    = {1},
  publisher = {Bibliopolis},
  year      = {1984},
  isbn      = {978-88-7088-228-5},
  timestamp = {Thu, 19 Sep 2019 11:29:54 +0200},
  biburl    = {https://dblp.org/rec/books/daglib/0000395.bib},
  bibsource = {dblp computer science bibliography, https://dblp.org}
}

@inproceedings{dynamicCheckStaticLanguage,
    author = {Abadi, M. and Cardelli, L. and Pierce, B. and Plotkin, G.},
    title = {Dynamic Typing in a Statically-Typed Language},
    year = {1989},
    isbn = {0897912942},
    publisher = {Association for Computing Machinery},
    address = {New York, NY, USA},
    url = {https://doi.org/10.1145/75277.75296},
    doi = {10.1145/75277.75296},
    abstract = {Statically-typed programming languages allow earlier error checking, better enforcement of disciplined programming styles, and generation of more efficient object code than languages where all type-consistency checks are performed at runtime. However, even in statically-type languages, there is often the need to deal with data whose type cannot be known at compile time. To handle such situations safely, we propose to add a type Dynamic whose values are pairs of a value v and a type tag T where v has the type denoted by T. Instances of Dynamic are built with an explicit tagging construct and inspected with a type-safe typecase construct.This paper is an exploration of the syntax, operational semantics, and denotational semantics of a simple language with the type Dynamic. We give examples of how dynamically-typed values might be used in programming. Then we discuss an operational semantics for our language and obtain a soundness theorem. We present two formulations of the denotational semantics of this language and relate them to the operational semantics. Finally, we consider the implications of polymorphism and some implementation issues.},
    booktitle = {Proceedings of the 16th ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages},
    pages = {213–227},
    numpages = {15},
    location = {Austin, Texas, USA},
    series = {POPL '89}
}

@article{hybridTypeChecking,
    author = {Knowles, Kenneth and Flanagan, Cormac},
    title = {Hybrid Type Checking},
    year = {2010},
    issue_date = {January 2010},
    publisher = {Association for Computing Machinery},
    address = {New York, NY, USA},
    volume = {32},
    number = {2},
    issn = {0164-0925},
    url = {https://doi.org/10.1145/1667048.1667051},
    doi = {10.1145/1667048.1667051},
    abstract = {Traditional static type systems are effective for verifying basic interface specifications. Dynamically checked contracts support more precise specifications, but these are not checked until runtime, resulting in incomplete detection of defects. Hybrid type checking is a synthesis of these two approaches that enforces precise interface specifications, via static analysis where possible, but also via dynamic checks where necessary. This article explores the key ideas and implications of hybrid type checking, in the context of the λ-calculus extended with contract types, that is, with dependent function types and with arbitrary refinements of base types.},
    journal = {ACM Trans. Program. Lang. Syst.},
    month = feb,
    articleno = {6},
    numpages = {34},
    keywords = {dynamic checking, static checking, Type systems, contracts}
}

@online{closures,
    author    = "Mozilla and individual contributors",
    title     = "MDN Web Docs: Closures",
    url       = "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Closures",
    urldate   = "2021-02-18"
}

@article{closureLambdaOp,
    author = {Sussman, Gerald and Steele, Guy},
    year = {1998},
    month = {12},
    pages = {405-439},
    title = {Scheme: A Interpreter for Extended Lambda Calculus},
    volume = {11},
    journal = {Higher-Order and Symbolic Computation},
    doi = {10.1023/A:1010035624696}
}

@book{GC,
    author = {Jones, Richard and Lins, Rafael},
    year = {1996},
    month = {08},
    pages = {},
    title = {Garbage Collection: Algorithms for Automatic Dynamic Memory Management},
    isbn = {978-0-471-94148-4}
}
