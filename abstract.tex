\newpage
{\Huge \bf Abstract}
\vspace{24pt} 

\textbf{Refinement Type in Real-World Programming}

Refinement Types provide a more expressive type checking and allow more errors to be caught automatically, however it is not a feature the general programmer is aware of. Existing research in the area is focused predominantly on the theoretical aspects of refinement types rather than their implementation in real-world programming. While there are certain programming languages available that support refinement types, these languages are often limited to a small number of research projects that are no longer maintained or simply open-source libraries that simulate a restricted form of refinement types. The introduction of refinement types in mainstream programming proves to be difficult because of features like mutation. Refinement types are able to make use of free variables in the program, this means that a change in the program state might affect the meaning of types, making type checking ambiguous. Furthermore, in general showing that a predicate holds is undecidable, making static type checking of refinement types hard. Our project aims to present refinement types with an emphasis on their behaviour in real-world programming languages. We achieve this by describing an imperative language named Simple-$R$ which strongly resembles C. We address the problems stated above by adapting multiple well-known concepts in programming languages such as immutable variables, closures and hybrid type checking. Using a combination of these techniques we formalise the rules for variables and pointers in Simple-$R$ in order to specify the behaviour of refinement types precisely. 

\newpage
\vspace{24pt}
Total word count: \wordcount
\vspace*{\fill}
