%% 
%% ACS project dissertation template. 
%% 
%% Currently designed for printing two-sided, but if you prefer to 
%% print single-sided just remove ",twoside,openright" from the 
%% \documentclass[] line below. 
%%
%%
%%   SMH, May 2010. 

\documentclass[a4paper,12pt]{report}
%TC:group tabular 1 1


%%
%% EDIT THE BELOW TO CUSTOMIZE
%%

\def\authorname{Xiu Hong\ Kooi\xspace}
\def\authorcollege{Wolfson College\xspace}
\def\authoremail{xhk20@cam.ac.uk}
\def\dissertationtitle{Exploring Dependent Types and Behaviour in Imperative Language}
\def\wordcount{0}


%\usepackage[dvips]{epsfig,graphics} 
\usepackage{epsfig,graphicx,verbatim,parskip,tabularx,setspace,xspace}
\usepackage{amsfonts}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{listings}
\usepackage{semantic}
\usepackage{float}

\usepackage[british]{babel}
\usepackage[%
  backend=bibtex      % biber or bibtex
%,style=authoryear    % Alphabeticalsch
 ,style=numeric-comp  % numerical-compressed
 ,sorting=none        % no sorting
 ,sortcites=true      % some other example options ...
 ,maxbibnames=99
 ,block=none
 ,indexing=false
 ,citereset=none
 ,isbn=true
 ,url=true
 ,doi=true            % prints doi
 ,natbib=true         % if you need natbib functions
]{biblatex}
\usepackage{biblatex}
\addbibresource{./dissertation.bib}


%% START OF DOCUMENT
\begin{document}


%% FRONTMATTER (TITLE PAGE, DECLARATION, ABSTRACT, ETC) 
\pagestyle{empty}
\singlespacing
\input{titlepage}
\onehalfspacing
\input{declaration}
\singlespacing
\input{abstract}

\pagenumbering{roman}
\setcounter{page}{0}
\pagestyle{plain}
\tableofcontents
\listoffigures
\listoftables

\onehalfspacing

%% START OF MAIN TEXT 

\chapter{Introduction}
\pagenumbering{arabic} 
\setcounter{page}{1} 
\textit{Type systems} \cite{typesystem} have been one of the most extensively researched field in 
Programming Languages. They act as a way from improving the reliability of a 
language by enforcing rules, preventing operations being applied on 
incompatible data. Type systems can be broken down into multiple categories but 
two of the most well known are \textit{Static} \cite{staticTyping} and 
\textit{Dynamic} \cite{dynamicTyping} typing. Mainstream programming 
languages such as \textit{Java} \cite{java}, \textit{C} \cite{c} and \textit{C++} \cite{cpp} 
uses the former while languages like \textit{Python} \cite{python} and 
\textit{JavaScript} \cite{js} uses the latter. 
Over the years, programming languages have included more powerful and flexible 
type systems, languages like \textit{C\#} \cite{cSharp} and \textit{Go} \cite{goInferenceType} allow 
\textit{type inference} \cite{inferenceType}, using a feature called \textit{Reflection} 
Java and Python can even achieve \textit{Duck Typing} \cite{javaDuckType}.

\par
However, as much as we have studied about type systems, \textit{Dependent Types} 
\cite{depenTypeAtWork} remains uncommon in the industry. While the theory of dependent types has been 
established several decades ago, only a small number of languages has 
integrate full dependent type support, most of them being functional languages. 
Dependent types allows the programmer to create types whose definition depends 
on a value. A type system that provides such refined control over the values it 
can take unlocks possibility that are previously unavailable such as 
domain-specific type checking at compile time. Furthermore, it acts as a built 
in ``error-handling'' code and could potentially 
reduces the lines of code a programmer needs to write. An in depth 
definition of dependent types is provided in the next section.

\par
The expressive nature of dependent types allow one to define complex 
mathematical assertations and hence lends itself to theorem proving systems. 
Mutliple functional languages such as \textit{Epigram} 
\cite{epigram} and \textit{Agda} \cite{agda} has 
built in support for dependent typing. However they remain niche and more 
mainstream languages like Java and C++ does not get the luxury. In chapter 2 of 
this dissertation we will be providing an in depth analysis of the current state 
of dependent types in programming languages and answer why dependent types are 
not more prominant in languages, in particular imperative languages.

\par
Multiple past research has studied and show the feasibility of an dependently typed 
imperative language. These studies has expressed the semantics of 
how an imperative languages would interact with dependent types and in some 
cases created a new language from the ground up. While we find these work novel 
and provided highly technical explanation to the field, they fail to caputure 
how this could relate to mainsteam programming languages. Furhtermore, the 
semantics provided in these studies are very complex with advanced language 
features, we propose that a more simple and barebone definiton will allow easier 
access to the literature and motivate more studies into dependenty types. 

\par
In chapter 3 we will be defining the syntax, typing rules and semantics 
of a basic language with dependent types support which will be studied 
and extended throughout the disseratation. In chapter 4 we will be observing 
multiple scenarios that dependent types cause uncertainties when used with 
imperative languages. We will be providing the semantics required for them 
to behave correctly. In chapter 5 we will discuss our work with regards to the 
existing work done in the area and how it completments the literature. 

\par
Finally we will conclude by discussing advanced features that can be integrated 
into our languages and how it can further complicate the language. We will also 
discuss some of the other considerations that need to be taken account when 
thinking about incorporating dependent types into a real language. 

\section{What Are Dependent Types}
In this section we will be providing the definitions of dependent types.

\subsection{Basic Definition}
At a very high level dependent types are types that depends on the value of 
another type. For example, we can define a type that captures only the even 
integers using the definition 
\verb+type EvenInt := { i : Int | i % 2 = 0}+. In this case we 
can say that the type EvenInt \textit{EvenInt} depends on the type \textit{int}.
Another commonly used example to describe dependent types would be a type like 
\verb+type FixVec<T, N> := { v : Vec<T> | len(v) = N}+, this type definition defines 
a vector or array of elements with type $T$ that always contains $N$ elements.

\subsection{Dependent $\Pi$ Types}
We can capture the definition mathematically using the notion of \textit{dependent 
product types}, i.e. $\Pi$ type. This is also sometimes referred to as 
\textit{dependent function type} as in this definition we construct a function 
$F: A \rightarrow B$. The function $F$ takes an element of type $A$ and 
gives us an element of type $B$ which depends on $A$. We express it 
mathematically using the $\Pi$ notation as
\begin{center}
 \begin{tabular}{l}
   $\prod x: A.  F(x)$
 \end{tabular} 
\end{center}

In this definition, $F(x)$ is the type family for the type $B$ that depends on $A$.
However $F$ could be a constant function, so we can also express the definition 
as $\Pi x:A.B$, in this case $B$ does not depend 
on the value $x$. Using the \textit{EvenInt} example from earlier, 
it can be defined as 
$\Pi x:Int.\text{ }\{ i:Int\text{ }|\text{ }i\text{ }\%\text{ }2\text{ }= 0\}$.

\par
Interestingly, the dependent product type correspond to the 
\textit{forall quantifier} as per 
the \textit{Curry–Howard correspondence}. The idea is that the dependent 
function $F(x)$ correspond to predicate $P(x)$ and thus the dependent product 
type has a one-to-one correspondence to $\forall x: A. P(x)$.

\subsection{Dependent $\Sigma$ Types}
In addition to the dependent product type, we have the notion of \textit{dependent sum 
types}, written as $\Sigma$ type. This is often referred to as the 
\textit{dependent pair type} as the resulting type here is an ordered pair. 
Specifically the resulting pair $\langle a,b \rangle$ is ordered such that the 
second element depends on the first element. The 
mathematical definition is similar to that of the product type
\begin{center}
 \begin{tabular}{l}
   $\langle a,b \rangle :\sum x: A.  F(x)$
 \end{tabular} 
\end{center}
In the case $a:A, b: F(x)$, similarly, $F$ could be a constant function and thus 
the expression is $\Sigma x:A.B$. Consider the following example, 

$\Sigma x: Int.\{y:Int\text{ }|\text{ } y = x * 2\}$, then the type would 
contain values like $\langle 1,2 \rangle$ and $\langle 4,8 \rangle$ where the 
second pair is doubled the first.

\par
Like the dependent product type, the dependent sum type correspond to a 
universal quantifier, in this case, the \textit{existential quantifier}. As 
per the Curry–Howard correspondence, $F(x)$ corresponds to predicate $P(x)$ 
thus $\Sigma x:A.F(x)$ correponds to $\exists x: A. P(x)$.

\par
While both dependent product types and dependent sum types are important to the 
literature, the project itself will mainly focus on the former. we believe that 
the the notion of pair in dependent sum types prove to be redundant in 
the construction a programming language and does not provide any additional 
value. The dependent product type is largely adequate for our goal.

\section{Overview of a Dependently Typed Language}
In this section we will discuss at a very high level the behaviour one would 
expect from a dependently typed language, its benefits and use cases.

\subsection{Language Behaviour}
The key behaviour we are interested in is regarding compile time type checking. 
For instance, using the example above, if a type is defined as an \textit{EvenInt} 
then if at any point in the code it becomes odd then it should be caught at 
compile time. 

\par
Consider the psedocode below: 
\begin{figure}[H]
  \begin{lstlisting}[mathescape=true] 
  function f(int x) {
    if (x \% 2 == 0) {
      ...
    }
    throw error ``x has to be even''
  }
  
  function dependent_f(EvenInt i) {
    ...
  }
  \end{lstlisting}
  \caption{Dependenty Typed Language Behaviour}
\end{figure}

\par
The function \textit{f} above checks whether the argument $x$ is even, if it 
isn't then it throws a runtime error. If dependent type is available, then if an 
invalid argument is passed in it should signal an error at compile time, saving the 
error handling code as shown in \textit{dependent\_f}. 

\subsection{Benefits of Dependent Types}
As we seen in the previous subsection, dependent types allows programmer to 
define much richer and expressive types that can be checked at compile time. The 
addition of dependent types allow for safer code as it is able to guarentee certain 
properties. 

\par
Furthermore, using dependent types eliminates the need for many trivial error 
handling code. Around 4\% of code in every program is dedicated to error 
handling \cite{errorHandlingCode}, dependent types will be able to reduce the 
numbers and allow the programmer more time to write the logical part of the 
code, indirectly leading to more robust codebases.

\par
Consider a banking system where users are able to transfer and withdraw 
money using a function, 
in order to prevent overdraft one might be able to define a function that takes 
a type \textit{Amount$<$T$>$}, a double type that is always 
greater than 0 and less than \textit{T}, where \textit{T} is the current balance in the account. 
This approach guarantees the amount is always valid without the need of writing 
error handling code. This example demonstrated using an object-oriented style 
language by Vasconcelos \cite{objOritentedDependentType}.


\chapter{Background: State of Dependent Types in Programming} 
In this chapter we will be reviewing the current knowledge of dependent types 
in different programming languages. It will cover languages with full dependent 
types support as well as some languages with similar concepts and point out how 
it differs from dependent types. Lastly we will summarise all these languages 
and point out some limitations and unknowns. 

\section{Functional Languages}

In this section we will be examining three functional languages with 
dependent typing. Functional languages 
uses the \textit{functional programming} \cite{overviewFP} paradigm which is a programming 
paradigm that constructs program using a series of function applications. In 
this paradigm, functions return values as oppose to altering the state of the 
program. In this programming paradigm, the language focuses on describing 
\textit{what} the program will accomplish.

\par

Many functional languages has the notion of purity, i) A function will always 
return the same value when given the same arguments. ii) The evaluation of a 
function has no side effects (changes to the state of the program).

\subsection{Agda}

\textit{Agda} \cite{agda} is a purely functional language originally developed by Ulf Norell in 
1999 however the first appearance the current version known as Agda 2 is in 
2007. Agda has all the necessary constructs one would expect in a functional 
language such as first-class functions, inductive definitions, pattern matching, 
etc. In addition to being a functional language, Agda also serves an automated theorem prover. 
Agda is one of the few programming language with native dependent type support. 

\par
The code listing below is an example of defining a fixed length vector in 
dependent type. 

\begin{figure}[H]
  \begin{lstlisting}[mathescape=true] 
  data Nat : Set where 
  zero : Nat
  suc  : Nat -> Nat  
  
  data EvenNat : Nat -> Set where
  even-zero  : EvenNat zero
  even-plus2 : {n : Nat} -> EvenNat n -> EvenNat (suc (suc n))
  
  data Vec (A : Set) : Nat -> Set where
  [] : Vec A zero
  _::_ : {n : Nat} -> A -> Vec A n -> Vec A (suc n)
  \end{lstlisting}
  \caption{Dependent Types in Agda}
\end{figure}

\par
While Agda provides dependent type support, it remains a niche language. One of 
the reason being its paradigm, Agda is \textit{purely functional} \cite{purelyFP}, meaning that 
all functions are pure (i.e. not relying on the program state or other mutable 
data). Functional languages are generally considered harder to learn and grasp 
compared to other paradigms \cite{fpHarder}. Furthermore, the general lack of 
awareness and competent users who can program dependent types contribute to Agda 
being a niche language in the programming world and is 
predominantly used for theorem proving.

\subsection{Haskell}
\textit{Haskell} \cite{haskell} is a purely functional programming language first appeared in 1990. In 
contrast to Agda, Haskell is often considered a more general purpose programming 
language. Haskell is among the most popular programming languages and argubly 
the most popular ``pure'' language in the world \cite{pypl}. 
Haskell has even been adopted by software companies such as Facebook \cite{haskellFB}.

\par
Haskell is not a language that supports dependent types natively however many 
extensions has been developed to simulate the experience. 
Generalised Algebraic Data Types (GADTs) are a generalization of the 
algebraic data types, it allows the programmer to 
explicitly write down the types of the constructors \cite{haskellGADT}. 
\begin{figure}[H]
  \begin{lstlisting}
    data Expr = I Int        
          | Add Expr Expr 
          | Mul Expr Expr 
  \end{lstlisting}
  \caption{A GADT defintion for arithmetic operations in Haskell}
\end{figure}

Using the power of GADT one could define dependent types as so

\begin{figure}[H]
  \begin{lstlisting}      
    data EvenNat (n :: Nat) where
      EvenZero  :: EvenNat 0
      EvenPlusTwo :: EvenNat n -> EvenNat (n + 2)
      
    data Vec a (n :: Nat) where
      Nil  :: Vec a 0
      (:>) :: a -> Vec a n -> Vec a (n + 1)
  \end{lstlisting}
  \caption{Dependent Types in Haskell}
\end{figure}

\par
Although GADTs provide a way of simulating dependent types in Haskell and 
argubly enough for simple dependent typing enough for many cases. 
Haskell does not qualify as a fully dependent 
language due to the lack of certain features such as dependent functions. There 
have been proposals to add full dependent type support to Haskell however a lot 
of work remains to be done \cite{dependentHaskell, aRoleForDependentHaskell}. 
Furthermore, while Haskell is significantly more well known compared to Agda, it 
still lack the popularity of languages like Java and Python.

\subsection{Idris}
\textit{Idris} \cite{idris} is a dependently typed functional language first 
appeared in 2007. Idris bears similarity with Agda, both in terms of paradigm 
and type system. However the differ in one crucial way, Idris is designed to 
emphasise general purpose programming rather than theorem proving. Earlier one 
we stated that one of the less desirable property of Agda was its niche because 
of its emphasis in theorem proving. Idris provides 
interoperability with systems libraries and C programs, 
as well as language constructs for domain specific language 
implementation \cite{gpIdris}. 

\par
Syntactically Idris is very similar to Agda, dependent types are defined as so: 
\begin{figure}[H]
  \begin{lstlisting}      
    data EvenNat :  Nat -> Type where
      EvenZero  :: EvenNat 0
      EvenPlusTwo :: EvenNat n -> EvenNat (n + 2)
      
    data Vect : Nat -> Type -> Type where
      Nil  : Vect 0 a
      (::) : (x : a) -> (xs : Vect n a) -> Vect (n + 1) a
  \end{lstlisting}
  \caption{Dependent Types in Idris}
\end{figure}

\par
While Idris offers interoperability with multiple mainstream programming 
languages such as C and JavaScript, Idris remain predominantly a research tool. 
Idris is not production ready \cite{gpIdris} as it is missing certain libraries 
and more importantly nobody is working on Idris full time. Furthermore Idris is 
still a functional language, hence suffering from the limitation stated earlier. 

\section{Imperative Languages}

In this section we will be discussing dependent typing with regards to imperative 
languages. Imprative languages uses the \textit{imperative programming} 
\cite{imperativeOverview} paradigm, in constrat to the functional 
programming, this pradigm emphasises \textit{how} a program will operate 
by using a series of statements to change the program state.

\par

Imperative languages can be further broken down into different categories, 
mainly Procedural and Object-Orinted. Many of the world's most popular languages 
fall into this two categories, C, FORTRAN, COBOL are examples of procedural 
languages while Java, C#, Kotlin are Object-Oriented Languages. Some languages such 
as C++, Python are multi-paradigm and allows the programmer to write code both 
in a procedural manner or object-oriented manner. 

\par

Currently there is no imperative programming language with proper dependent type 
support, however the are some aspect of different languages that resembles 
dependent typing. 


\subsection{C++ Templates}
\textit{C++ Templates} \cite{cppTemplate} are a way of passing the type of a 
data as a parameter so certain code can be reused. For instance, the same 
sorting algorithm can be used on multiple data types such as \textit{int} and 
\textit{double}, using templates the programmer will not need to write the same 
sorting function multiple times for different data types. 

\par
Templates are often compared to Java's \textit{Generics} \cite{javaGenerics} 
as the C++ equivalent. While this statement is mostly true, C++ templates 
differ in a big way. 
Generics only allow the template parameter to be a class, templates on the other 
hand allow the parameter to be a class, values or pointers. The ability to 
pass values into a template to create types certainly resembles dependent types.

\par
The code listing below is an example of templates with values. It defines the 
struct that represents an integer less than N. 

\begin{figure}[H]
  \begin{lstlisting}[language=c++]     
    template <int N>
    struct LessThanN {
      int value;
      LessThanN(int x) {
        if (x < N)
            value = x;
        else
           throw ``invalid type'';
      }
    };
  \end{lstlisting}
  \caption{Struct dependent on values using C++ Templates}
\end{figure}

\par
Using the above definition it is possible to define types such as \\
\verb+LessThanN<5> ltf = LessThanN<5>(3)+, this will define a type that will has 
to be less than 5. However, certain questions arise from this definition, 

i) What will happen if the constructor is given an invalid argument? 

ii) What if the template parameter is a variable and its 
value change? 

iii) What if the value of \textit{value} change during execution?

In the subsequent text, the term ``Dependent Value'' will be used to refer to the 
value $N$ and ``Value'' will refer to the actual value held by a LessThanN type, 
i.e. the \textit{value} state in the struct. 

\subsubsection{The Intended Behaviour}
First, we observe the intended behaviour of LessThanN using the following test 
code:
\begin{figure}[H]
  \begin{lstlisting}[language=c++]     
    int main() {
      LessThanN<5> ltf = LessThanN<5>(3);
      cout << ltf.value; // Prints out 3
      return 0;
    }
  \end{lstlisting}
  \caption{Intended Behaviour of LessThanN in C++}
\end{figure}

\par
As expected, the code compiles perfectly and outputs 3 when executed.

\subsubsection{Invalid Definition of LessThanN}
In order to observe the behaviour of i), we simply have to pass in an 
invalid value into the constructor, i.e. a value greater than N, 
the test is conducted using the code below. 

\begin{figure}[H]
  \begin{lstlisting}[language=c++]     
    int main() {
      LessThanN<5> ltf = LessThanN<5>(10); // Error here
      cout << ltf.value; 
      return 0;
    }
  \end{lstlisting}
  \caption{Invalid Definition of LessThanN in C++}
\end{figure}

\par
Interestingly, the code compiles perfectely despite the invalid definition. 
However it fails to execute as the exeception thrown in the \textbf{else} clause 
is left uncaught. This behaviour makes it no better than an simple if statement 
in the constructor. An addition in C++ 11 was the introduction of 
\textit{constexpr} and \textit{static\_assertation}. These allow for certain 
compile time checking, however the values checked must fulfil 
the \textit{constant expression} requiremets \cite{cppConstExpr}. 

\par
Modifying the \textbf{struct} to use the code below we get compile time type 
checking. 

\begin{figure}[H]
  \begin{lstlisting}[language=c++]     
    template <int N, int M>
    struct LessThanN {
      int value;
      LessThanN() {
        static_assert(M < N, ``type is invalid'');
        value = M;
      }
    };
  \end{lstlisting}
  \caption{LessThanN with Compile Time Type Checking in C++}
  \label{code:compileLTN}
\end{figure}

\par
Now, providing an invalid definition yields a compile time error, with the 
following: 
\verb+LessThanN<10, 12> ltf = LessThanN<10, 12>;+ 

\textbf{static\_assert failed due to requirement `12 $<$ 10' ``type is invalid''}

\subsubsection{Mutation of Template Variable}
In our previous example we have been passing integer literal as the template 
parameter for the dependent value. Often programmers are required to 
work with varied values through variables, how will this effect the behaviour? 

\par
Consider the following hypothetical situation using the struct defined in 
figure \ref{code:compileLTN}: 

\begin{figure}[H]
  \begin{lstlisting}[language=c++]     
    int n = 5;
    LessThanN<n, 3> ltf = LessThanN<n, 3>();
    n = 2; // Is ltf still well typed??
  \end{lstlisting}
  \caption{Mutating the Dependent Variable for LessThanN in C++}
\end{figure}

\par
Compiling the above code leads to a compile time error, C++ requires template 
arguments to be constant expressions. In order to use variables as template 
arguments, they have to be defined \textbf{const}. In which case the above 
situation is impossible as the variable $n$ now cannot be changed. 

\subsubsection{Changing The Value of Struct During Execution}
We've showed that it is not possible to change the dependent value in 
the program, however what if the value changes? Will a 
variable be well-typed on one line and ill-typed on the next line? 

\par
Consider the following code: 
\begin{figure}[H]
  \begin{lstlisting}[language=c++]     
    const int n = 5;
    LessThanN<n, 3> ltf = LessThanN<n, 3>(); // Well typed
    ltf.value = 10; // Now ill-typed but not caught
  \end{lstlisting}
  \caption{Mutating the value of LessThanN in C++}
\end{figure}

\par
In order to achieve our intended behaviour there has to be some form of check 
that runs throughout the lifetime of the program, currently there is no native 
support for this form of invariant. However one potential workaround as a 
programmer would be to make the LessThanN type immutable, by setting \textit{value} 
to be a \textbf{const} however that significantly limits the usability of the 
language. 

\par
We see glimpses of dependent typing in certain imperative languages, the 
examples using C++ presented above is one of them. One could argue arrays in 
Java and C++ resembles the fixed size vector however they are quite similar. In 
the subsequent chapters of this dissertation we will define a language to 
address these uncertainties. 

\chapter{The Simple-$\Pi$ Language}
To address the uncertainties introduced in the previous chapter and provide a 
base for research in dependent types among imperative languages, we look to 
define a basic language called Simple-$\Pi$. This chapter will introduce 
the language's syntax and typing rules. The language follows 
the imperative paradigm, specifically a procedural language.

\section{Language Syntax}
This section will describe the syntax for the Simple-$\Pi$ language. 

\begin{figure}[H]
  \begin{center}
    \begin{tabular}{l l l}
      \textit{Types} & $T$ & $:\text{ }int\text{ }|\text{ }bool\text{ }|\text{ }\Pi x: A.P(x)
      \text{ }|\text{ }T \times T\text{ }|\text{ }void$\\
      \textit{Functions} & $\lambda$ & $:\text{ }T\longrightarrow T$\\
      \textit{Operators} & $ops$ & $:$ $+$ $|$ $-$ $|$ $\wedge$ $|$ $\vee$ \\
      \textit{Expressions} & $e$ & $:$ $vals$ $|$ $x$ $|$ $x\text{ }:= e$ $|$ 
      $e_1 + e_2$ $| \text{ }e_1 - e_2$ $|$ $e_1 \wedge e_2$ $|$ \\ 
      & & \; $e_1 \vee e_2$ $|$ $e1;e2$ $|$ \textbf{if} $e_1$ \textbf{then} $e_2$ \textbf{then} $e_3$ $|$\\
      & & \;  \textbf{while} $e_1$ \textbf{do} $e_2$ $|$ 
      $\text{\textbf{call}}(x, e)$ $|$ \textbf{skip}\\
      \textit{Variables} & $vars$& $:$ $x \in {a,b,c...z}$\\
      \textit{Values} & $vals$& $:$ $\mathbb{Z}$ $|$ $\mathbb{B}$ $|$ $(e, e')$ $|$ $\{a\text{ }:
      \text{ }T\text{ }|\text{ } P(a)\}$\text{ }$|$ $\lambda x.e$\\
      \textit{Value Variable Context} & $\Gamma$& $:$ $vars \mapsto vals$
    \end{tabular}
  \end{center}
  \caption{Language Syntax for Simple-$\Pi$}
\end{figure}

\paragraph{Types} The Simple-$\Pi$ language has support the following five data types. 
\begin{itemize}
  \item The basic integer type \textit{int}
  \item The basic boolean type \textit{bool}
  \item The dependent product type, written as $\Pi x: A.P(x)$, is used to 
  define a type $B$ that depends on the variable $x$ of type A.
  \item The product type $(T \times T)$ which denotes an ordered pair $(T, T)$.
  \item The \textit{void} type to represent empty or null.
\end{itemize}

\paragraph{Functions}
Functions are defined in Simple-$\Pi$ as $(T \longrightarrow T)$, taking a type 
and returning a type. Using the product type, representation of a function 
taking multiple parameter can be achived using a pair with containing a pair. 
For instance, a function $f(x,y,z)$ can be formalised as 
$\lambda$ : $(T \times T) \times T \longrightarrow T$. Note that functions are 
not first-class in this language.

\paragraph{Operators}
The language supports the following built in operators.
\begin{itemize}
  \item Integer addition using the $+$ operator writte in an infix notation.
  \item Integer subtraction using the $-$ operator written in an infix notation.
  \item Logical conjunction using the $\wedge$ operator written in an infix 
  notation.
  \item Logical disjunction using the $\wedge$ operator written in an infix 
  notation.
\end{itemize}

\paragraph{Expressions} The following expressions make up the language.
\begin{itemize}
  \item Variable and values represents the most basic form of an expression.
  \item The four operators are expressions operator on two other expressions $e_1$ 
  and $e_2$
  \item The assignment statement $(:=)$ assigns an expression $e_1$ to a 
  free variable $x$.
  \item The \textbf{if then} and \textbf{while do} statements are the standard control flow 
  operations one would expect.
  \item The \textbf{call} statement is used to indicate function calls, 
  \textbf{call}($x, e$) will invoke the function bounded to $x$ using the 
  parameter $e$.
  \item The \textbf{skip} statment is use to indicate an empty expression and 
  does not perform any meaningful action. 
\end{itemize}

\paragraph{Variables and Values} In Simple-$\Pi$, all variable are reference 
variables, as one would expect in imperative programming. We use $x$ to denote a 
variable. Variables can take values as suggested by the types, all the integer 
literals $\mathbb{Z}$, booleans $\mathbb{B}$, dependent type values 
$\{x: T\text{ }|\text{ }P(x)\}$ and functions $\lambda x.e$.

\paragraph{Value Variable Context} Variables are mapped to values in the program 
context $\Gamma$. Each reference variable is allowed to only appear once in 
the context. We use \textbf{dom}($\Gamma$) to retrive the domain which represent 
the set of declared variables. We will use the notation $\Gamma(x)$ 
to retrieve the value bound to variable $x$.

\section{Typing Rules}
This section defines the typing rules for the Simple-$\Pi$ language.

\par
We begin by defining the typing judgement. The typing judgement used in 
Simple-$\Pi$ takes the form of the standard notation. 
\begin{center}
  $\Gamma \vdash e : T$
\end{center}
This judgement represents that expression $e$ under the context $\Gamma$ has the 
type $T$.

\par
Using the judgement rule we can easily define the fist two typing rules for base 
values \textit{int} and \textit{bool}.

\begin{figure}[H]
  \begin{center}
    \begin{tabular} {c}
      $\forall n \in \mathbb{Z}$, $\Gamma \vdash n : int$ & 
      $\forall b \in \mathbb{B}$, $\Gamma \vdash b : bool$ &       
    \end{tabular}
  \end{center}
  \caption{Typing Rules for Base Values}
\end{figure}

\par
Functions are treated similarly, a function $\lambda x.e$ with function type 
$T \longrightarrow T$ under context $\Gamma$ is written as 
$\Gamma \vdash \lambda x.e : T \longrightarrow T$.

\par
The remaining typing rules for the operators, statements and function 
calls are presented in figure 3.3 below.

\begin{figure}[H]
  \begin{center}
    \begin{tabular} {c}
      \inference {\Gamma \vdash e_1: int & \Gamma \vdash e_2: int}
        {\Gamma \vdash e_1 + e_2 : int}[(+)] \text{ }
      \inference {\Gamma \vdash e_1: int & \Gamma \vdash e_2: int} 
        {\Gamma \vdash e_1 - e_2 : int}[(-)] & \\
      \inference {\Gamma \vdash e_1: bool & \Gamma \vdash e_2: bool}
        {\Gamma \vdash e_1 \wedge e_2 : bool}[($\wedge$)] \text{ }
      \inference {\Gamma \vdash e_1: bool & \Gamma \vdash e_2: bool} 
        {\Gamma \vdash e_1 \vee e_2 : bool}[($\vee$)] & \\
      \inference {\Gamma \vdash e_1: bool \\ \Gamma \vdash e_2: T & \Gamma \vdash e_3: T}
        {\Gamma \vdash \text{\textbf{if }} e_1 \text{\textbf{ then }} 
        e_2 \text{\textbf{ else }} e_3: T}[(\textbf{if else})]
      \inference {\Gamma \vdash e_1: bool & \Gamma \vdash e_2: T}
        {\Gamma \vdash \text{\textbf{while }} e_1 \text{\textbf{ do }} e_2 : T} [(\textbf{while do})] & \\
      \inference {\Gamma \vdash x: T & \Gamma \vdash e_1: T} 
        {\Gamma \vdash x := e_1 : T} [($:=$)] \text{ }
      \inference {\Gamma(x) = \lambda x.e \\ \Gamma \vdash x : T_1 \longrightarrow T_2  & \Gamma \vdash e_1: T_1}
        {\Gamma \vdash \text{\textbf{call}}(x, e_1) : T_2}[(\textbf{call})]
    \end{tabular}
  \end{center}
\caption{Basic Typing Rules for Simple-$\Pi$}
\end{figure}

Most of the typing rule are straightforward and what one would expect from the 
type checker. For ther function call, notice that the variable $x$ has to be a 
function in the context. The type of the function is from $T_1 \longrightarrow 
T_2$, because multiple arguments are represented as pairs for a n-nary function, 
we avoid having to arbitrary check the argument type $T_1$ to $T_n$.


\par
Finally we define the formation, introduction and elimination rules for 
the dependent product types as follows.

\begin{figure}[H]
  \begin{center}
    \begin{tabular} {c}
      \inference {\Gamma \vdash A : T \\ \Gamma, x : A \vdash P(x) : T} 
        {\Gamma \vdash \Pi x. P(x) : T}[($\Pi$ F)] \text{ }
      \inference {\Gamma \vdash A : T \\ \Gamma, x : A \vdash e : P(x)} 
        {\Gamma \vdash \lambda x : A. e : \Pi x : A. P(x) }[($\Pi$ I)] & \\
      \inference {\Gamma \vdash f : \Pi x : A. P(x) & \Gamma \vdash x : A} 
        {\Gamma, x: A \vdash f(x) : P(x)}[($\Pi$ E)] \text{ }
    \end{tabular}
  \end{center}
  \caption{Typing Rules for the Dependent Product Type}
\end{figure}

\par
The dependent product type formation rule ($\Pi$ F) defines the rules in order 
for a dependent product type to be formed. The introduction rule ($\Pi$ I) 
defines the rules in order for expressions to take the type of $\Pi$. Finally, 
the elimination rule ($\Pi$ E) acts as the modus ponens of $\Pi$ I and states 
how from an expression of $\Pi$ one could gets the expression of others type. 


\chapter{Semantics for Simple-$\Pi$}
In this chapter we will define the basic semantics for Simple-$\Pi$, we will 
then build up the semantics gradually to formalise the behavour of certain 
non-trivial behaviour involving dependent types such as assignments and 
mutation. In the final section of this chapter we will extend the syntax in 
order to incorporate vectors into the language.

\section{Operational Semanctics}
In this section we will define the \textit{operational semantics} 
\cite{operationalSemantics} of the language.

\par
We will use the \textit{Structured Operational Semantics} \cite{plotkinSOS} to 
formalise the basic semantics. Throughout the text we will use the following 
metavariables. 
\begin{itemize}
  \item The metavarible $ops$ to range over all operators.
  \item The metavariable $s$ to range over all states $\Gamma$ 
  (mapping from variables to values). The operator $\uplus$ when used on 
state $s$ with $\{x \mapsto e\}$ update the state $s$ such that now $s(x) = 
e$.
  \item The metavariable $v$ to range over all values.
  \item Uppercase letters $A,B,C$ to range over all types.
  \item Greek letters ($\alpha$, $\pi$, $\upsilon$) to define local varibles in 
  the formuli. 
\end{itemize}
Figure 4.1 defines the operation semantics to capture the basic behaviour of 
Simple-$\Pi$.

\begin{figure}[H]
  \begin{center}
  \begin{tabular} {c}
      $\langle v, s \rangle \longrightarrow \langle v, s \rangle$ ($vals$ evaluation) 
      & \\
      \inference {n = n_1 + n_2}{\langle n_1 + n_2, s \rangle \longrightarrow \langle n, s\rangle}[(op +)] \text{ }
      \inference {n = n_1 - n_2}{\langle n_1 - n_2, s \rangle \longrightarrow \langle n, s\rangle}[(op -)]
      & \\
      \inference {b = b_1 \wedge b_2}{\langle b_1 \wedge b_2, s \rangle \longrightarrow \langle b, s \rangle}[(op $\wedge$)] \text{ }
      \inference {b = b_1 \vee b_2}{\langle b_1 \vee b_2, s \rangle \longrightarrow \langle b, s \rangle}[(op $\vee$)]
      & \\
      \inference {\langle e_1, s\rangle \longrightarrow \langle e'_1, s\rangle & 
        \langle e_2, s\rangle \longrightarrow \langle e'_2, s\rangle }
        {\langle e_1\text{ }ops\text{ }e_2, s  
        \rangle \longrightarrow \langle e'_1\text{ }ops\text{ }e'_2, s \rangle}[($ops$)]
      & \\
      \inference {\langle e_1, s \rangle \longrightarrow \langle e'_1, s' \rangle}
        {\langle e_1;e_2, s \rangle \longrightarrow \langle e'_1;e_2, s' \rangle}[($e_1;e_2$)]
      & \\
      $\langle \text{\textbf{skip}};e2, s \rangle \longrightarrow \langle e2, s \rangle$ (\textbf{skip})
      & \\
      $\langle \text{\textbf{if }} true \text{\textbf{ then }} e_1 \text{\textbf{ else }} 
        e_2, s \rangle \longrightarrow \langle e_1, s\rangle$ (\textbf{if} true)
      & \\
      $\langle \text{\textbf{if }} false \text{\textbf{ then }} e_1 \text{\textbf{ else }} 
        e_2, s \rangle \longrightarrow \langle e_1, s\rangle$ (\textbf{if} false)
      & \\
      \inference {\langle e, s\rangle \longrightarrow \langle e', s \rangle}
        {\langle \text{\textbf{if }} e \text{\textbf{ then }} e_1 \text{\textbf{ else }} 
        e_2, s \rangle \longrightarrow \langle \textbf{if } e \text{\textbf{ then }} e_1 \text{\textbf{ else }} 
        e_2, s \rangle}[(\textbf{if} $expr$)] 
      & \\
      $\langle \text{\textbf{while }} c \text{\textbf{ do }} e, s \rangle \longrightarrow \langle 
        \text{\textbf{if }} c \text{\textbf{ then }} e;
        (\text{\textbf{while }} c \text{\textbf{ do }} e) \text{\textbf{ else }} \textbf{skip}, s \rangle$ (\textbf{while do})
      & \\
      $\langle x := v, s \rangle \longrightarrow \langle skip, s \uplus \{x \mapsto v\} \rangle $ (assignment $vals$)
      & \\
      \inference {\langle e, s \rangle \longrightarrow \langle e', s' \rangle} 
      {\langle x := e, s \rangle \longrightarrow \langle x := e', s'\rangle} (assignment $expr$ ) \text{ }
      & \\
      \inference {\lambda_1 = \lambda x.e}
        {\langle \textbf{call}(\lambda_1, x), s \rangle \longrightarrow \langle e, s \rangle}[(\textbf{call})] 
    \end{tabular}
  \end{center}
  \caption{Operational Semantics for Simple-$\Pi$}
\end{figure}

\section{Dependent Types Semantics}
Programming languages often have a wide range of features, often the team behind 
the language have to put extensive thought into the design decisions. As there 
are often multiple way to handle a certain feature, rarely are there a definite 
answer to which is the most optimal.

\par
The same applies to dependent types, which is a feature itself. This section 
will cover the different ways of handling dependent types and they interact with 
other features.

\subsection{Defining Dependent Types with Variable}
Consider the uncertainty of using variables to define dependent types. For 
instance: 

\begin{figure} [H]
  \begin{center}
    $y\text{ }:\text{ }int := 10$ \\
    $BoundedIntY$ = $\Pi y. \{i : Int\text{ }|\text{ }i < y\}$ \\ 
    $y := 5$
  \end{center}
  \caption{Mutation to Variable A Dependent Type Depends On}
\end{figure}
\par
How would this behaviour work in practice? Recall from chapter 2 we proposed the 
question of what should happen when the value bound to the variable change. In 
this subsection we will define semantics to formalise the behaviour.

\subsubsection{Passing by Value}
In the first subsection we will define a method of handling the above 
uncertainty using a pass by value approach. In languages such as C/C++, 
\textit{pass by value} \cite{pbv} is a way of passing a parameter into a 
function in a way that any modification to the parameter in the function does 
not reflect changes outside and vice versa. 

\par
A similar approach can be taken in our definitions for dependent types. For 
instance, taking the example in figure 4.2, if the variable $y$ in the dependent 
type function is different from the variable $y$ in the program state, then any 
changes to the variable $y$ will not effect the type definition and the program 
will stay well typed. 

\par
In order to achieve this, our dependent type function should be have its own 
local context so it does not overlap with the program's context. We use the 
notation $\sigma$ as a local context. The context behaves, just as the program's 
context $\Gamma$ would, mapping variables to values.

\par
We would also need a similar mapping for types, notice that we defined a name 
for the type $BoundedInt$ in the example. We use $\tau$ to represent the type 
variable map. The syntax is extended by adding the following: 

\begin{figure}[H]
  \begin{center}
    \begin{tabular} {l l l}
      \textit{Expression} & $e$ & $:$ ... $|$ $x = T$ \\
      \textit{Value Variable Context} & $\Gamma, \sigma$& $:$ $vars \mapsto 
      vals$ \\
      \textit{Type Variable Context} & $\Upsilon$& $:$ $vars \mapsto T$ \\
    \end{tabular}
  \end{center}
  \caption{Extended Syntax for Simple-$\Pi$}
\end{figure}

\par
Notice in the example above we use an equal sign (=) to denote a new type. 
First we define its rule, $t$ ranges over all Type Variable Context:

\begin{figure}[H]
  \begin{center}
    \begin{tabular} {c}
      \inference {x \notin \text{\textbf{dom}}(s)}{\langle x = A, s, t \rangle \longrightarrow 
        \langle \text{\textbf{skip}}, s, t \uplus \{x \mapsto A\}\rangle}[(= type assign)] \text{ }    
    \end{tabular}
  \end{center}
\end{figure}

In order to formalise the behaviour and correctness we opted to use 
\textit{Hoare Logic} \cite{hoare}. The \textit{Hoare Triple} is defined as follows: 

\begin{figure}[H]
  \begin{center}
    $\{P\}C\{Q\}$
  \end{center}
  \caption{Hoare Triple}
\end{figure}
The Hoare triple simply expresses that given precondition $P$ holds then after executing $C$ 
and $C$ terminates, the postcondition $Q$ will hold.

\par 
We use the notation $P[x/a]$ to denote that in the function $P$, replace all 
occurence of variable $x$ with variable $a$. We use the context $\sigma_P$  
to denote the local context of function $P$. The rules for dependent type 
definition written using hoare logic is as follows: 


\begin{figure}[H]
  \begin{center}
    \small$\{x \notin \text{\textbf{dom}}(\Gamma) \wedge \alpha = \Gamma(x) \wedge \sigma_P = \Gamma\}
    y = \Pi x : A. P(x)\{P =  P[x/\alpha] \wedge y \in \text{\textbf{dom}}(\Upsilon)\}$ 
    \normalsize
  \end{center}
  \caption{Dependedent Type Definition Rule using Hoare Logic}
\end{figure}

\par
The precoditions states that the $\alpha$ is the value of $x$ in the 
program context. After execution the type assignment, 
the function $P$ would have been substituted 
such that all occurence of variable $x$ is replaced with the value $\alpha$. Note 
that we are substituting the variable with a value, essentially fixing the value 
of $x$ in the function. So any changes to $x$ in the program will now no longer 
have an impact on the type.

\par
This semantic allow the language to allow us to define types using variable 
whose value are available at runtime, i.e. a non constant variable. It provides 
more flexibility in comparison to C++ templates but it is still has limitations. The 
programmer might sometimes be looking for dependent types whose definitions 
changes with the value of the variable. 

\subsubsection{Dynamic Dependent Types}
In this subsection we will be presenting an approach to handling dependent types 
in imperative languages called \textit{Dynamic Dependent Types}. It is a type 
that will allow the definition of dependent types to change during runtime and 
still guarantees a well-typed program. 


\begin{figure} [H]
  \begin{center}
    $y\text{ }:\text{ }int := 10$ \\
    $BoundedIntY$ = $\Pi y. \{i : Int\text{ }|\text{ }i < y\}$ \\ 
    $x\text{ }:\text{ }BoundedIntY := 4$ \\
    $y := 5$ \\
  \end{center}
  \caption{Dynamically Changing Dependent Types}
\end{figure}

Figure 4.6 extends the previous example, in this scenario, the variable $x$ is 
of type $BoundedIntY$ and has the value 4 which is well typed. In the next line, 
the value of $y$ is reassigned the value 5. In this approach, rather than having 
no effect on the type definition, the type of $BoundedIntY$ changes with the 
value $y$, being now bounded to $5$. In our example, $x$ is still well typed so 
everything is valid. 


\begin{figure} [H]
  \begin{center}
    $y\text{ }:\text{ }int := 10$ \\
    $BoundedIntY$ = $\Pi y. \{i : Int\text{ }|\text{ }i < y\}$ \\ 
    $x\text{ }:\text{ }BoundedIntY := 6$ \\
    $y := 5$ // Error \\
  \end{center}
  \caption{Ill-Typed Dynamically Changing Dependent Types}
\end{figure}

\par
If the reassignment of $y$ causes $x$ to be ill-type as demonstrated in the 
example above, then the type checker should flag it at compile time. 

\par
In order to do this we need will need to type check all variables against its 
type after an assignment. Notice that currently the variable mapping does not 
provide the type that a variable possess, we only have the value. We would have 
to modify out syntax to include this necessary information. 

\par
We opted to use the following notation for our context: 
\begin{figure}[H]
  \begin{center}
    \begin{tabular} {l l l}
      \textit{Value Variable Context} & $\Gamma, \sigma$& $:$ $vars \mapsto vals : T$ 
    \end{tabular}
  \end{center}
  \caption{Extended Value Variable Context with Type}
\end{figure}

This means that a varible now maps to a value with type $T$. The notation of 
$\Gamma(x)$ to retrieve a value used in previous semantics still hold, now we 
can write $\alpha : \tau = \Gamma(x)$ which gets $\alpha$ the value of $x$ 
and $\tau$ the type of $x$. This notation allows us to apply the universal 
quantifier in order to type check all the variables of a certain type. 









\chapter{Related Work}

\chapter{Further Work}

\chapter{Summary and Conclusions} 


\appendix
\singlespacing

\printbibliography

\end{document}
